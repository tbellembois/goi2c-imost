package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net"
	"strconv"
	"time"

	"math/rand"

	"github.com/d2r2/go-i2c"
	"github.com/d2r2/go-logger"

	"collectd.org/api"
	"collectd.org/network"

	"github.com/google/uuid"
)

const (
	maxFakeTemp int32 = 30  // maximum fake temperature
	minFakeTemp int32 = 10  // minimum fake temperature
	delimiter   byte  = 0xF // socket data delimiter
)

var (
	i2cConn                 *i2c.I2C
	i2cDeviceID             string
	collectdServerConn      *network.Client
	collectdServerConnected bool
	ctx                     context.Context
	data                    []byte
	err                     error

	flagSendFrequency         string
	sendFrequencyDuration     time.Duration
	flagRetryConnectFrequency string
	retryConnectFrequency     time.Duration
	flagServerAddress         string
	serverAddress             string
	flagServerPort            int
	serverPort                string
	flagI2cAddress            string
	i2cAddress                uint8
	flagI2cBus                int
	i2cBus                    int
	flagFakeData              bool   // generate fake data instead of querying the i2c probe
	flagFakeSend              bool   // print data instead of sending them
	flagFakeId                string // only if flagFakeData=true, i2c device id can be specified
)

// Get preferred outbound ip of this machine.
// reference: https://stackoverflow.com/questions/23558425/how-do-i-get-the-local-ip-address-in-go
func GetOutboundIP() net.IP {
	conn, err := net.Dial("udp", "8.8.8.8:80")
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	localAddr := conn.LocalAddr().(*net.UDPAddr)

	return localAddr.IP
}

func connectServer() {

	collectdServerConnected = false
	ctx = context.Background()

	log.Printf("connecting to %s port %s", serverAddress, serverPort)
	for !collectdServerConnected {

		if collectdServerConn, err = network.Dial(net.JoinHostPort(serverAddress, serverPort), network.ClientOptions{}); err == nil {
			log.Printf("connected to %s port %s", serverAddress, serverPort)
			collectdServerConnected = true
		}

		if err != nil {
			log.Printf("-> %s", err.Error())
			log.Printf("retrying in %s seconds", flagRetryConnectFrequency)

			time.Sleep(retryConnectFrequency)
		}

	}

}

func fakeConnectServer() {

	log.Println("faking server connectiong")
	collectdServerConnected = true

}

func init() {

	flag.StringVar(&flagSendFrequency, "sendFrequency", "60s", "data sending frequency in seconds (default 60s)")
	flag.StringVar(&flagRetryConnectFrequency, "retryConnectFrequency", "5s", "server connection retry frequency in seconds (default 5s)")
	flag.StringVar(&flagServerAddress, "serverAddress", "127.0.0.1", "server address (default 127.0.0.1)")
	flag.IntVar(&flagServerPort, "serverPort", 25826, "server port (default 25826)")
	flag.StringVar(&flagI2cAddress, "i2cAddress", "66", "i2c device adress (default 66)")
	flag.IntVar(&flagI2cBus, "i2cBus", 1, "i2c bus (default 1)")
	flag.BoolVar(&flagFakeData, "fakeData", false, "do not get data from the i2c device, simulate it instead")
	flag.StringVar(&flagFakeId, "fakeId", "localhost", "with fakeData, specify the i2c device id (autogenerated by default)")
	flag.BoolVar(&flagFakeSend, "fakeSend", false, "do not send data to the server, print it instead")
	flag.Parse()

	// Uncomment/comment next line to suppress/increase verbosity of output.
	if err = logger.ChangePackageLogLevel("i2c", logger.InfoLevel); err != nil {
		log.Fatal(err)
	}

}

func main() {

	// Initializing variables.
	serverPort = strconv.Itoa(flagServerPort)
	serverAddress = flagServerAddress
	if retryConnectFrequency, err = time.ParseDuration(flagRetryConnectFrequency); err != nil {
		log.Fatal(err)
	}
	if sendFrequencyDuration, err = time.ParseDuration(flagSendFrequency); err != nil {
		log.Fatal(err)
	}
	var i64 int64
	if i64, err = strconv.ParseInt(flagI2cAddress, 10, 8); err != nil {
		log.Fatal(err)
	}
	i2cBus = flagI2cBus
	i2cAddress = uint8(i64)

	// I2C connection.
	if flagFakeData {

		if flagFakeId == "" {
			i2cDeviceID = uuid.NewString()
		} else {
			i2cDeviceID = flagFakeId
		}

	} else {

		log.Printf("connecting to i2c device at address %d bus %d", i2cAddress, i2cBus)
		if i2cConn, err = i2c.NewI2C(0x66, 1); err != nil {
			log.Fatal(err)
		}
		defer i2cConn.Close()

		// Getting device ID.
		if _, err = i2cConn.WriteBytes([]byte{0x20}); err != nil {
			log.Fatal(err)
		}
		if data, _, err = i2cConn.ReadRegBytes(0x20, 2); err != nil {
			log.Fatal(err)
		}
		//i2cDeviceID = fmt.Sprintf("%v", data[0])
		i2cDeviceID = GetOutboundIP().String()
		// data[1] is the Major/Minor Revision ID.

		// Thermocouple Sensor Configuration.
		log.Println("-> setting up thermocouple sensor configuration")
		if _, err = i2cConn.WriteBytes([]byte{0x05, 0b00000111}); err != nil {
			log.Fatal(err)
		}

		// DeviceConfiguration.
		log.Println("-> setting up device configuration")
		if _, err = i2cConn.WriteBytes([]byte{0x06, 0b01111100}); err != nil {
			log.Fatal(err)
		}

	}

	log.Printf("-> i2c device ID: %s", i2cDeviceID)

	for {

		// Waiting for a server.
		if flagFakeSend {

			fakeConnectServer()

		} else {

			connectServer()

		}

		vl := &api.ValueList{
			Identifier: api.Identifier{
				Host:   fmt.Sprintf("sonde-%s", i2cDeviceID),
				Plugin: "digitemp",
				Type:   "gauge",
			},
			Time:     time.Now(),
			Interval: sendFrequencyDuration,
		}

		if flagFakeData {

			ranTtemperature := rand.Int31n(maxFakeTemp-minFakeTemp) + minFakeTemp
			vl.Values = []api.Value{api.Gauge(float64(ranTtemperature))}

		} else {

			//
			// Read hot junction command
			//
			if _, err = i2cConn.WriteBytes([]byte{0x00}); err != nil {
				log.Fatal(err)
			}
			if data, _, err = i2cConn.ReadRegBytes(0x00, 2); err != nil {
				log.Fatal(err)
			}

			// Calculating hot junction temperature.
			hotTemp := (float64(data[0]) * float64(16)) + (float64(data[1]) / float64(16))
			if fmt.Sprintf("%08b", data[0]) == "1" {
				hotTemp = hotTemp - 4096
			}

			log.Printf("- hot temp: %f", hotTemp)
			vl.Values = []api.Value{api.Gauge(hotTemp)}

			//
			// Read delta command
			//
			if _, err = i2cConn.WriteBytes([]byte{0x01}); err != nil {
				log.Fatal(err)
			}
			if data, _, err = i2cConn.ReadRegBytes(0x01, 2); err != nil {
				log.Fatal(err)
			}

			// Calculating delta temperature.
			deltaTemp := (float64(data[0]) * float64(16)) + (float64(data[1]) / float64(16))
			if fmt.Sprintf("%08b", data[0]) == "1" {
				deltaTemp = deltaTemp - 4096
			}

			log.Printf("- delta temp: %f", deltaTemp)

			//
			// Read cold junction command
			//
			if _, err = i2cConn.WriteBytes([]byte{0x02}); err != nil {
				log.Fatal(err)
			}
			if data, _, err = i2cConn.ReadRegBytes(0x02, 2); err != nil {
				log.Fatal(err)
			}

			// Calculating cold junction temperature.
			coldTemp := (float64(data[0]) * float64(16)) + (float64(data[1]) / float64(16))
			if fmt.Sprintf("%08b", data[0]) == "1" {
				coldTemp = coldTemp - 4096
			}

			log.Printf("- cold temp: %f", coldTemp)

		}

		if flagFakeSend {

			log.Printf("%+v", vl.Values)

		} else {

			log.Printf("data sent %+v", vl.Values)
			if err = collectdServerConn.Write(ctx, vl); err != nil {
				log.Println(err)
			}

			if err = collectdServerConn.Close(); err != nil {
				log.Println(err)
			}

		}

		time.Sleep(sendFrequencyDuration)

	}

}
